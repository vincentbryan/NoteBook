### 1.概述

* 函数调用会导致两件事情发生 如果函数已经被声明为 inline 内联 则函数体可能已经在编译期间它的调用点上就被展开 如果没有被声明为 inline 则函数在运行时才被调用 
* 函数声明由函数返回类型 函数名和参数表构成 这三个元素被称为函数声明 (function declaration) 或函数原型 (function prototype )，一个函数可在一个文件中被声明多次



### 2.参数传递

所有的函数都使用在程序运行栈 (run-time stack) 中分配的存储区 该存储区一直保持与该函数相关联，直到函数结束为止 ，那时存储区将自动释放以便重新使用，该函数的整个存储区被称为活动记录 (activation record)

系统在函数的活动记录中为函数的每个参数都提供了存储区，参数的存储长度由它的类型来决定，**参数传递是指用函数调用的实参值来初始化函数参数存储区的过程**

#### 2.1 按值传递

C++中参数传递的缺省初始化方法是把实参的值拷贝到参数的存储区，这被称为按值传递。

缺点是内存消耗大，和无法改变传进来参数的值

#### 2.2 引用传递

当参数是引用时，函数接收的是实参的左值而不是值的拷贝，这意味着函数知道实参在内存中的位置。因而能够改变它的值或取它的地址。以下三种情况，经常使用引用传递：

* 希望函数改变参数的值
* 希望返回额外的值
* 传递一个大类型，如果不希望被修改，可使用const进行修饰

**引用VS指针**

引用：引用必须被初始化为指向一个对象，一旦初始化了，它就不能再指向其他对象

指针：指针可以指向一系列不同的对象也可以什么都不指向

#### 2.3 数组参数

在C++中，数组永远不会按值传递，以下三个声明是等价的：

```cpp
void func(int*);
void func(int[]);
void func(int[10]);
```

因为数组被传递为指针，所以这对程序员有两个含义：

1. 在被调函数内对参数数组的改变将被应用到数组实参上而不是本地拷贝上 
2. 数组长度不是参数类型的一部分 函数不知道传递给它的数组的实际长度 编泽器也不知道，当编译器对实参类型进行参数类型检查时，并不检查数组的长度

#### 2.4 抽象类型参数

#### 2.5 缺省实参

#### 2.6 省略号



### 3. 返回值

如果返回值是一个大型类对象，用引用或指针返回类型比按值返回类对象效率要高得多。在某些情况下，编译器自动将按值返回转换到按引用返回 该优化被称为命名返回值优化

当声明一个返回引用的函数时 程序员应当知道下面两个易犯的错误：

1. 返回一个指向局部对象的引用

   局部对象的生命期随函数的结束而结束，在函数结束后 该引用变成未定义内存的别名 

2. 函数返回一个左值，对返回值的任何修改都将改变被返回的实际对象 

   为防止对引用返回值的无意修改 返回值应该被声明为 const



向一个函数传递参数发生错误的可能性随参数表的长度的增加而提高，作为一个通用规则 8 个参数应该是最大值了，为了替换一个大型的参数表 程序员可以将参数声明为类数组或某一种容器类型，这样的参数可以用来包含一组参数值

类似的情况 一个函数只能返回一个值，如果程序的逻辑要求返回多个值，那么程序员可以将某些函数参数声明为引用，在这种情况下，函数可以直接修改相应的实参，因而程序员可以设置这些实参含有某些额外的返回值或者程序员可以声明一个函数它的返回类型是一个可以包含一组返回值的类或某一种容器类型



### 4. inline

一个函数被指定为 inline 函数 则它将在程序中每个调用点上被内联地展开，但是，注意 inline 指示对编译器来说只是一个建议，编译器可以选择忽略该建议。因为把一个函数声明为 inline 函数并不见得真的适合在调用点上展开



### 5.extern



### 6. 函数指针

