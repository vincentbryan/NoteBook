### 1. 域

C++支持三种形式的域：局部域(local scope)，名字空间域(namespace scope)和类域(class scope)。域和名字解析是编译时刻的概念，它们应用在程序文本的某一部分上



###2. 全局对象



### 3. 局部对象

在局部域中的变量声明引入了局部对象(local object)有三种局部对象：自动对象(automatic object)， 寄存器对象 (register object) 以及局部静态对象 (local static object)，区分这些对象的是对象所在存储区的属性和生命期。

1. 自动对象所在存储区从声明它的函数被调用时开始 一直到该函数结束为止
2.  寄存器对象是一种自动对象 它支持对其值的快速存取 
3. 局部静态对象的存储区在该程序的整个执行期间一直存在 



### 4. 动态分配对象

动态分配的对象被分配在程序的空闲存储区 free store 的可用内存池中，程序员用 new 表达式创建动态分配的对象，用delete 表达式结束此类对象的生命期。动态分配的对象可以是单个对象，也可以是对象的数组。在空闲存储区中分配的数组的长度可以在运行时刻计算

#### 4.1 单个对象的动态分配与释放

```cpp
int *ptr = new int(512);
delete ptr;
```

delete 表达式只能应用在指向的内存是用 new 表达式从空闲存储区分配的指针上，将delete 表达式应用在指向空闲存储区以外内存的指针上，会使程序运行期间出现未定义的行为 

#### 4.2 auto_ptr

auto_ptr 对象被初始化为指向由 new 表达式创建的动态分配对象。当 auto_ptr 对象的生命期结束时，动态分配的对象被自动释放。

```cpp
#include<memory>

auto_ptr<int> ptr(new int(1024));
```

**auto_ptr的所有权**

```cpp
auto_ptr< int > p1( new int( 1024 ) );
auto_ptr< int > p2( new int( 2048 ) );
p1 = p2;
```

在赋值之前 由 p1 指向的对象被删除 。赋值之后 p1拥有 int 型对象的所有权，该对象值为 2,048 ，p2 不再被用来指向该对象。

为了重置一个 auto_ptr 对象 我们必须使用 reset()函数：

```cpp
auto_ptr< string >
pstr_auto( new string( "Brontosaurus" ) );
// 在重置之前删除对象 Brontosaurus
pstr_auto.reset( new string( "Long -neck" ) );
```

auto_ptr 类模板为动态分配内存提供了大量的安全性和便利，但是，我们仍需小心，否则就会陷入麻烦，我们可能会做错些什么呢：

1. 能用一个指向 内存不是通过应用 new 表达式分配的指针来初始化或赋值 auto_ptr
2. 不能让两个 auto_ptr 对象拥有空闲存储区内同一对象的所有权

#### 4.3 数组的动态分配与释放

new 表达式也可以在空闲存储区中分配数组．在这种情况下 new 表达式中的类型指示符后面必须有一对方括号，里面的维数是数组的长度

```cpp
// 分配单个 int 型的对象
// 用 1024 初始化
int *pi = new int(1024);

// 分配一个含有 1024 个元素的数组
// 未被初始化
int *pia = new int[1024];

// 分配一个含 4x1024 个元素的二维数组
int (*pia2)[ 1024 ] = new int[ 4 ][ 1024 ];
```

在空闲存储区中创建的内置类型的数组必须在 for 循环中被初始化，即数组的元素被一个接一个地初始化

为避免动态分配数组的内存管理带来的问题 一般建议使用标准库 vector list 或 string容器类型 这些类型都会自动管理内存分配 



